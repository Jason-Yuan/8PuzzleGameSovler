from eight_puzzle_game_state import EightPuzzleGameState

"""The adjacent_tiles array holds a mapping of adjacent tiles from a single tile position for the eight puzzle game state. 
"""

adjacent_tiles = [(1,3),(0,2,4),(1,5),(0,4,6),(1,3,5,7),(2,4,8),(3,7),(4,6,8),(5,7)]

solution_state_as_array = ['1','2','3','4','5','6','7','8','x']

class GameTreeNode(object):
    """A node belonging to a game tree.
       The node contains the current state and its relationship in the tree:
       _state which is an instance of an EightPuzzleGameState.
       _children which is a list of other game tree nodes generated by the current node.
       _parent which is the parent node of the current node.
    """

    __slots__ = {'_state', '_children', '_parent', '_value'}

    def __init__(self, game_state_as_array, parent_node):
        self._state = EightPuzzleGameState(game_state_as_array)
        self._parent = parent_node
        self._children = []

    def generate_children(self):
        """Generates children based on each distinct possible next move of the blank tile according to the adjacent_tiles dictionary.
        """

        if self._state.data != solution_state_as_array:
            for position in adjacent_tiles[self._state.blank_position]:
                if self._parent is None:
                    self._generate_child(position)
                else:
                    if position != self._parent.state.blank_position:
                        self._generate_child(position)


    def _generate_child(self, swap_position):
        """To generate a child, make a shallow copy of the current state.
           Then swap the blank space with the tile who is in the swap position.
           swap_position - the position adjacent to the blank space tile that can be swapped.
           swap_element - the tile to be swapped.
        """

        new_state = self._state.data[:]
        swap_element = new_state[swap_position]
        new_state[swap_position] = new_state[self._state.blank_position]
        new_state[self._state.blank_position] = swap_element
        self._children.append(GameTreeNode(new_state,self))
                    
    @property
    def state(self):
        """Gets the board representation of current state of the node.
        """
        return self._state

    @property
    def parent(self):
        """Gets the parent node of the current node.
        """
        return self._parent

    @property
    def children(self):
        """Gets the children nodes of the current node.
        """
        return self._children

    @property
    def value(self):
        """Gets the value of the current node
        """
        return self._value

    @value.setter
    def value(self, some_value):
        """Set the value of the current node
        """
        self._value = some_value

    def __repr__(self):
        return str(self._state)

    __str__ = __repr__

    def __cmp__(self, other):
        """Setup the compare function for GameTreeNode object
           Consider the value attribute when comparing
        """
        if self._value < other._value:
            return -1
        elif self._value > other._value:
            return 1
        else:
            return 0
